name: Build specific target

on:
  workflow_dispatch:
    inputs:
      target_dir:
        description: 'Which directory to build: app1, app2, app3, all'
        required: true
        default: 'app1'
      use_latest_env:
        description: 'Try to pull env images before building (true/false)'
        required: false
        default: 'true'

permissions:
  contents: read
  actions: write

jobs:
  build-target:
    runs-on: ubuntu-latest
    env:
      GHCR_REG: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare workspace
        run: |
          # ensure clean output
          rm -rf output || true
          mkdir -p output

      - name: Set variables
        id: vars
        run: |
          echo "target=${{ github.event.inputs.target_dir }}" >> $GITHUB_OUTPUT
          echo "use_latest=${{ github.event.inputs.use_latest_env }}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Log in to GHCR
        if: ${{ secrets.GHCR_PAT != '' }}
        run: echo "${{ secrets.GHCR_PAT }}" | docker login ${GHCR_REG} -u ${{ github.repository_owner }} --password-stdin

      - name: Try pull env images
        if: steps.vars.outputs.use_latest == 'true'
        run: |
          docker pull ${GHCR_REG}/${{ github.repository }}/qt-log4cpp-app:latest || true
          docker pull ${GHCR_REG}/${{ github.repository }}/java-app:latest || true

      - name: Build selected targets
        run: |
          set -euo pipefail
          TARGET="${{ steps.vars.outputs.target }}"
          build_one() {
            app="$1"
            echo "=== Building ${app} ==="
            case "${app}" in
              app1|app2)
                image="${GHCR_REG}/${{ github.repository }}/qt-log4cpp-app:latest"
                workdir="/app/${app}"
                ;;
              app3)
                image="${GHCR_REG}/${{ github.repository }}/java-app:latest"
                workdir="/app/${app}"
                ;;
              *)
                echo "Unknown app: ${app}"
                return 1
                ;;
            esac
            # run build inside env image; copy.sh should write to host's output/<app>
            docker run --rm -v "${{ github.workspace }}":/app -w "${workdir}" "${image}" \
              sh -c "chmod +x build.sh copy.sh || true && ./build.sh && ./copy.sh"
          }

          if [ "${TARGET}" = "all" ]; then
            for a in app1 app2 app3; do
              build_one "${a}"
            done
          else
            build_one "${TARGET}"
          fi

      - name: Show output
        run: |
          echo "=== Host: output ==="
          ls -la output || true
          ls -R output || true

      - name: Upload artifact for target
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: output-${{ github.event.inputs.target_dir }}
          path: |
            output/${{ github.event.inputs.target_dir }}
            # if all, upload whole output
            output

      - name: Create image tags
        id: set_image_ref
        run: |
          short=${GITHUB_SHA::8}
          echo "image_ref_sha=ghcr.io/${{ github.repository }}/qt-log4cpp-bin:sha-${short}" >> $GITHUB_OUTPUT
          echo "image_ref_latest=ghcr.io/${{ github.repository }}/qt-log4cpp-bin:latest" >> $GITHUB_OUTPUT

      - name: Build artifact image
        env:
          IMAGE_SHA: ${{ steps.set_image_ref.outputs.image_ref_sha }}
          IMAGE_LATEST: ${{ steps.set_image_ref.outputs.image_ref_latest }}
        run: |
          if [ ! -d output ] || [ -z "$(ls -A output)" ]; then
            echo "No output/ or it's empty; skipping artifact image build."
            exit 0
          fi
          # build using Dockerfile.artifact; use output as context so COPY output/ /artifact/ picks current files
          docker build -t "${IMAGE_SHA}" -t "${IMAGE_LATEST}" -f Dockerfile.artifact .
          docker push "${IMAGE_SHA}"
          docker push "${IMAGE_LATEST}"

name: CI/CD with Docker Cache (Qt + log4cpp)

permissions:
  actions: write
  contents: read

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      revision_from:
        description: 'Range start (branch or commit SHA). Optional.'
        required: false
        type: string
      revision_to:
        description: 'Range end (branch or commit SHA). Optional. If empty, workflow run ref is used.'
        required: false
        type: string
      select_all:
        description: 'Build all targets regardless of changes (true/false). Optional.'
        required: false
        type: boolean
      use_latest_env:
        description: 'Try to pull env images before building (true/false). Optional.'
        required: false
        type: boolean
        default: true

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      IMAGE_REF_SHA: ${{ steps.set_image_ref.outputs.image_ref_sha }}
      IMAGE_REF_LATEST: ${{ steps.set_image_ref.outputs.image_ref_latest }}
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code (full history for diff)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Try pull env images if requested
        if: ${{ github.event.inputs.use_latest_env == 'true' }}
        run: |
          docker pull ghcr.io/${{ github.repository }}/qt-log4cpp-app:latest || true
          docker pull ghcr.io/${{ github.repository }}/java-app:latest || true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Log in to GitHub Container Registry
        run: |
          if [ -n "${{ secrets.GHCR_PAT }}" ]; then
            echo "Logging in to GHCR..."
            echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
          else
            echo "GHCR_PAT not set; skipping GHCR login."
          fi

      # Resolve revisions for range (FROM..TO)
      - name: Resolve revisions for range
        id: revs
        run: |
          set -euo pipefail
          FROM_INPUT="${{ github.event.inputs.revision_from || '' }}"
          TO_INPUT="${{ github.event.inputs.revision_to || '' }}"
      
          # If this is a pull_request event, prefer the PR head/base SHAs
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # github.event.pull_request may be present; use head.sha and base.sha
            PR_HEAD_SHA="${{ github.event.pull_request.head.sha || '' }}"
            PR_BASE_SHA="${{ github.event.pull_request.base.sha || '' }}"
            if [ -n "$PR_HEAD_SHA" ]; then
              TO_INPUT="$PR_HEAD_SHA"
            fi
            if [ -n "$PR_BASE_SHA" ] && [ -z "$FROM_INPUT" ]; then
              FROM_INPUT="$PR_BASE_SHA"
            fi
          fi
      
          # default TO: use workflow run ref (branch) or HEAD if not provided
          if [ -z "$TO_INPUT" ]; then
            if [ -n "${GITHUB_REF:-}" ]; then
              TO_INPUT="${GITHUB_REF#refs/heads/}"
            else
              TO_INPUT=""
            fi
          fi
      
          echo "Inputs after PR handling: FROM='${FROM_INPUT}' TO='${TO_INPUT}'"
      
          git remote set-url origin "https://github.com/${GITHUB_REPOSITORY}.git"
          git fetch --no-tags --prune origin +refs/heads/*:refs/remotes/origin/* || true
      
          # If TO_INPUT looks like a pull ref (refs/pull/...), fetch it explicitly
          if echo "$TO_INPUT" | grep -q '^refs/pull/'; then
            git fetch --no-tags origin "$TO_INPUT" || true
          fi
      
          if [ -n "$FROM_INPUT" ]; then
            # try to fetch the FROM ref/sha
            git fetch --no-tags origin "$FROM_INPUT" || true
          fi
          if [ -n "$TO_INPUT" ]; then
            git fetch --no-tags origin "$TO_INPUT" || true
          fi
      
          # resolve TO commit
          if [ -n "$TO_INPUT" ]; then
            TO_COMMIT=$(git rev-parse --verify --quiet "$TO_INPUT" || true)
            if [ -z "$TO_COMMIT" ]; then
              # fallback: if FETCH_HEAD exists (e.g., fetch of PR merge), try it
              if git rev-parse --verify --quiet FETCH_HEAD >/dev/null 2>&1; then
                TO_COMMIT=$(git rev-parse --verify --quiet FETCH_HEAD || true)
              fi
            fi
            if [ -z "$TO_COMMIT" ]; then
              echo "::error::Failed to resolve TO '$TO_INPUT' to a commit"
              exit 1
            fi
          else
            TO_COMMIT=$(git rev-parse --verify --quiet HEAD)
            if [ -z "$TO_COMMIT" ]; then
              echo "::error::Failed to resolve HEAD"
              exit 1
            fi
          fi
      
          # resolve FROM commit: if empty, use parent of TO
          if [ -n "$FROM_INPUT" ]; then
            FROM_COMMIT=$(git rev-parse --verify --quiet "$FROM_INPUT" || true)
            if [ -z "$FROM_COMMIT" ]; then
              echo "::error::Failed to resolve FROM '$FROM_INPUT' to a commit"
              exit 1
            fi
          else
            parent=$(git rev-list --parents -n 1 "$TO_COMMIT" | awk '{print $2}')
            if [ -n "$parent" ]; then
              FROM_COMMIT="$parent"
            else
              FROM_COMMIT=""
            fi
          fi
      
          echo "from_commit=${FROM_COMMIT}" >> $GITHUB_OUTPUT
          echo "to_commit=${TO_COMMIT}" >> $GITHUB_OUTPUT
          echo "Determined range: ${FROM_COMMIT}..${TO_COMMIT}"

      - name: Get files changed in commits between FROM..TO
        id: changed
        run: |
          set -euo pipefail
          FROM="${{ steps.revs.outputs.from_commit }}"
          TO="${{ steps.revs.outputs.to_commit }}"

          if [ -z "$TO" ]; then
            echo "::error::No TO commit resolved"
            exit 1
          fi

          if [ -z "$FROM" ]; then
            files=$(git ls-tree -r --name-only "$TO")
          else
            files=$(git diff --name-only "${FROM}" "${TO}")
          fi

          uniq_files=$(echo "$files" | sed '/^$/d' | sort -u)
          echo "Changed files:"
          echo "$uniq_files"

          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$uniq_files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Map changed files to targets
        id: detect
        run: |
          set -euo pipefail
          files="${{ steps.changed.outputs.files }}"
          app1=false; app2=false; app3=false
          dockerfile=false; dockerfile_java=false
      
          if [ -n "$files" ]; then
          # echo してパイプで while に渡す（here-doc を使わない）
            echo "$files" | while IFS= read -r f; do
              case "$f" in
                app1/*) app1=true ;;
                app2/*) app2=true ;;
                app3/*) app3=true ;;
                Dockerfile)
                  dockerfile=true
                  # Dockerfile の変更で全アプリ再ビルドにしたければ以下を有効化
                  app1=true; app2=true; app3=true
                  ;;
                Dockerfile.java)
                  dockerfile_java=true
                  app3=true
                  ;;
              esac
            done
          fi

          echo "app1=$app1" >> $GITHUB_OUTPUT
          echo "app2=$app2" >> $GITHUB_OUTPUT
          echo "app3=$app3" >> $GITHUB_OUTPUT
          echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
          echo "dockerfile_java=$dockerfile_java" >> $GITHUB_OUTPUT

      # -----------------------
      # C++ 環境イメージ（使い回し + キャッシュ）
      # -----------------------
      - name: Try to pull C++ env image (use cached env if available)
        id: pull_cpp_env
        run: |
          if docker pull ghcr.io/${{ github.repository }}/qt-log4cpp-app:latest; then
            echo "pulled_cpp=true" >> $GITHUB_OUTPUT
          else
            echo "pulled_cpp=false" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Docker image (cache)
        if: steps.pull_cpp_env.outputs.pulled_cpp == 'false' || steps.detect.outputs.dockerfile == 'true'  # Dockerfileに変更があれば再ビルド
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}/qt-log4cpp-app:latest,ghcr.io/${{ github.repository }}/qt-log4cpp-app:sha-${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}/qt-log4cpp-app:cache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}/qt-log4cpp-app:cache,mode=max

      # -----------------------
      # Java 環境イメージ（使い回し + キャッシュ）
      # -----------------------
      - name: Try to pull Java env image (use cached env if available)
        id: pull_java_env
        run: |
          if docker pull ghcr.io/${{ github.repository }}/java-app:latest; then
            echo "pulled_java=true" >> $GITHUB_OUTPUT
          else
            echo "pulled_java=false" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Java env image (with cache)  # 必要時に再ビルドしてキャッシュ保存
        if: steps.pull_java_env.outputs.pulled_java == 'false' || steps.detect.outputs.dockerfile_java == 'true'  # Dockerfile.javaに変更があれば再ビルド
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.java
          push: true
          tags: ghcr.io/${{ github.repository }}/java-app:latest,ghcr.io/${{ github.repository }}/java-app:sha-${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}/java-app:cache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}/java-app:cache,mode=max

      - name: Build and Copy artifacts app1 (only if changed)
        if: steps.detect.outputs.app1 == 'true'
        run: |
          echo "=== Building app1 ==="
          docker run --rm -v ${{ github.workspace }}:/app -w /app/app1 ghcr.io/${{ github.repository }}/qt-log4cpp-app:latest \
            sh -c "chmod +x build.sh copy.sh || true && ./build.sh && ./copy.sh"

      - name: Build and Copy artifacts app2 (only if changed)
        if: steps.detect.outputs.app2 == 'true'
        run: |
          echo "=== Building app2 ==="
          docker run --rm -v ${{ github.workspace }}:/app -w /app/app2 ghcr.io/${{ github.repository }}/qt-log4cpp-app:latest \
            sh -c "chmod +x build.sh copy.sh || true && ./build.sh && ./copy.sh"

      - name: Build and Copy artifacts app3 (only if changed)
        if: steps.detect.outputs.app3 == 'true'
        run: |
          echo "=== Building app3 ==="
          docker run --rm -v ${{ github.workspace }}:/app -w /app/app3 ghcr.io/${{ github.repository }}/java-app:latest \
            sh -c "chmod +x build.sh copy.sh || true && ./build.sh && ./copy.sh"

      - name: Show host-side output directory (copy source)
        run: |
          echo "=== Host: output/ (コピー元) ==="
          ls -la output || true
          echo "=== Recursive listing ==="
          ls -R output || true

      - name: Create image tags and set outputs
        id: set_image_ref
        run: |
          short_sha=${GITHUB_SHA::8}
          tag_sha="sha-${short_sha}"
          tag_latest="latest"
          image_base="ghcr.io/${{ github.repository }}/qt-log4cpp-bin"
          image_ref_sha="${image_base}:${tag_sha}"
          image_ref_latest="${image_base}:${tag_latest}"
          echo "image_ref_sha=${image_ref_sha}" >> $GITHUB_OUTPUT
          echo "image_ref_latest=${image_ref_latest}" >> $GITHUB_OUTPUT
          echo "Created tags: ${image_ref_sha} and ${image_ref_latest}"

      - name: Build artifact image
        env:
          IMAGE_SHA: ${{ steps.set_image_ref.outputs.image_ref_sha }}
          IMAGE_LATEST: ${{ steps.set_image_ref.outputs.image_ref_latest }}
        run: |
          if [ ! -d output ] || [ -z "$(ls -A output)" ]; then
            echo "No output/ or it's empty; skipping artifact image build."
            exit 0
          fi
          # Dockerfile.artifact は output/ を /artifact にコピーする最小箱
          docker build -t "${IMAGE_SHA}" -t "${IMAGE_LATEST}" -f Dockerfile.artifact .
          docker push "${IMAGE_SHA}"
          
      - name: call package (only dispatch)
        if: github.event_name == 'workflow_dispatch'
        uses: ./.github/workflows/package.yml
          docker push "${IMAGE_LATEST}"
